[{"content":" Spring 简化了数据库访问：\n提供简化的访问 JDBC 的模板类，不必手动释放 提供一个统一的 DAO 类以实现 Data Access Object模式 把 SQLException 封装为 DataAccessException，这是一个 RuntimeException 能方便地继承 Hibernate、JPA 和 MyBatis 这些数据库访问框架 使用 JDBC 引入以下依赖：\norg.springframework:spring-context:6.0.0 org.springframework:spring-jdbc:6.0.0 jakarta.annotation:jakarta.annotation-api:2.1.1 com.zaxxer:HikariCP:5.0.1 org.hsqldb:hsqldb:2.7.1 在 AppConfig 中，创建以下几个必须的 Bean：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Configuration @ComponentScan @PropertySource(\u0026#34;jdbc.properties\u0026#34;) // 读取数据库配置文件 public class AppConfig { @Value(\u0026#34;${jdbc:url}\u0026#34;) // 注入配置文件的相关配置 String jdbcUrl; @Value(\u0026#34;${jdbc.username}\u0026#34;) String jdbcUsername; @Value(\u0026#34;${jdbc.password}\u0026#34;) String jdbcPassword; @Bean DataSource createDataSource() { // 创建需要用到注入的配置 HikariConfig config = new HikariConfig(); config.setJdbcUrl(jdbcUrl); config.setUsername(jdbcUsername); config.setPassword(jdbcPassword); config.addDataSourceProperty(\u0026#34;autoCommit\u0026#34;, \u0026#34;true\u0026#34;); config.addDataSourceProperty(\u0026#34;connectionTimeout\u0026#34;, \u0026#34;5\u0026#34;); config.addDataSourceProperty(\u0026#34;idleTimeout\u0026#34;, \u0026#34;60\u0026#34;); // 创建 DataSource 实例，实际类型为 HikariDataSource return new HikariDataSource(config); } @Bean JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) { return new JdbcTemplate(dataSource); } } 在需要访问数据库的 Bean 中，注入 JdbcTemplate：\n1 2 3 4 @Component public class UserService { @Autowired JdbcTemplate jdbcTemplate; 使用 JdbcTemplate T execute(ConnectionCallback action) 方法，提供了 Connection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public User getUserById(long id) { // 传入 ConnectionCallback return jdbcTemplate.execute((Connection conn) -\u0026gt; { // 可以直接使用 conn 实例，不用释放，回调结束后 jdbcTemplate 自动释放 // 在内部手动创建的 PreparedStatement、ResultSet 必须用 try(...) 释放 try (var ps = conn.prepareStatement(\u0026#34;SELECT * FROM users WHERE id = ?\u0026#34;)) { ps.setLong(1, id); try (ResultSet rs = ps.executeQuery()) { if (rs.next()) { return new User( rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;email\u0026#34;), rs.getString(\u0026#34;password\u0026#34;), rs.getString(\u0026#34;name\u0026#34;) ); } throw new RuntimeException(\u0026#34;user not found by id:\u0026#34; + id); } } }); } T execute(String sql, PreparedStatementCallback action)，PreparedStatement 实例已经由JdbcTemplate 创建，并在回调后自动释放: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public User getUserByName(String name) { return jdbcTemplate.execute(\u0026#34;SELECT * FROM users WHERE name = ?\u0026#34;, (PreparedStatement ps) -\u0026gt; { // PreparedStatement 实例已经由 JDBCTemplate 创建，并在回调后自动释放 ps.setString(1, name); try (ResultSet rs = ps.executeQuery()) { if (rs.next()) { return new User( rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;email\u0026#34;), rs.getString(\u0026#34;password\u0026#34;), rs.getString(\u0026#34;name\u0026#34;) ); } throw new RuntimeException(\u0026#34;user not found by name: \u0026#34; + name); } }); } T queryForObject(String sql, RowMapper rowMapper, Object\u0026hellip; args)，传入 SQL 以及 SQL 参数后，JdbcTemplate 会自动创建 PreparedStatement，自动执行查询并返回 ResultSet，我们提供的RowMapper 需要做的事情就是把 ResultSet 的当前行映射成一个 JavaBean 并返回。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public User getUserByEmail(String email) { // 传入 SQL，参数和 RowMapper 实例 return jdbcTemplate.queryForObject(\u0026#34;SELECT * FROM users WHERE email = ?\u0026#34;, (ResultSet rs, int rowNum) -\u0026gt; { // 将 ResultSet 的当前行映射为一个 JavaBean return new User( rs.getLong(\u0026#34;id\u0026#34;), rs.getString(\u0026#34;email\u0026#34;), rs.getString(\u0026#34;password\u0026#34;), rs.getString(\u0026#34;name\u0026#34;) ); } ); } JdbcTemplate 设计的目的就是为了避免繁琐的 try\u0026hellip;catch 语句\n使用声明式事务 使用 DAO 集成 Hibernate 集成 JPA 集成 MyBatis ","date":"2024-08-28T20:40:00+08:00","permalink":"https://example.com/p/spring%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/","title":"Spring访问数据库"},{"content":"1 数据结构 1.1 算法复杂度 时间复杂度和空间复杂度\n大 O 复杂度表示法\n舍去低阶、常量、系数\n2 常见数据结构 2.2.1 数组： 存储方式：\n内存中连续的空间，存储相同的数据类型；\n增删改查：\n遍历：\n2.2.2 链表： 存储方式：\n内存中离散的结点，data（数据）和 next（下一个元素的地址）；\n增删改查：\n遍历：\n2.2.3 栈： 存储方式：\n满足先进后出的存储结构；\n入栈和出栈操作：\n2.2.4 队列： 满足先进先出的存储结构；\n入队和出队操作；\n2.2.5 散列表 理想的哈希表是不会产生冲突，即每一个元素的键（Key）都不相同的数组，但显然这种数据结构在计算机有限的空间下无法实现，注定产生哈希冲突；\n哈希冲突的解决方案决定了哈希表的具体数据结构：\n链地址\nJava 中采用的方案，将冲突的值将通过链表存储，并根据一定的规则将链表转换为红黑树（红黑树相对链表能显著优化查找速度）\n开放定址、再哈希法、公共溢出区\u0026hellip;\n衡量一个哈希算法的好坏主要参考该算法能否将数据均匀的映射到Key的取值范围中\n2.2.6 二叉树： data 域和 左右儿子的指针\n","date":"2024-08-28T20:02:00+08:00","permalink":"https://example.com/p/%E9%9B%86%E5%90%88%E5%85%AB%E8%82%A1%E6%96%87/","title":"集合八股文"},{"content":"AOP Aspect Oriented Programming，即面向切面编程\n何谓面向切面？我们对一个在 OOP 中的 BookService 的业务组件来考察，它应该会有几个业务方法：\ncreateBook updateBook deleteBook 那么，对于每个方法，我们都会需要设置安全检查、记录日志等等的公共逻辑，它们会重复的出现在各个业务方法中。在这些方法的某些代码段中就会出现重复的代码，加入把他们当作火腿肠一般并在一排，用刀切开就能够去考察这些切面了。\n对将这些切面如何正确的组装进火腿肠来说，有三种方法：\n在准备原料的时候就将它们按照顺序排列好，然后一次性注入进肠衣； 在将原料注入到肠衣的时候，按照需要的顺序先注入一种然后再切换到另外的； 业务逻辑这种原料先全部注入，然后按照需要切开再组装。 上述所言是在太过抽象，也或许并不贴且，但我们可以先有较为具体的例子，再去看对应到 Java 中 AOP 将切片织入到 BookService 的具体方案：\n编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ 就扩展了 Java 编译器，使用关键字 aspect 来实现织入； 类加载器：在目标类被装载到 JVM 时，通过一个特殊的类加载器，对目标类的字节码重新“增强”； 运行期：目标对象和切面都是普通 Java 类，通过 JVM 的动态代理功能或者第三方库实现运行期动态织入。 Spring 的 AOP 实现就是基于 JVM 的动态代理。\n由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过CGLIB或者Javassist这些第三方库实现。\n装配 AOP Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点 Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行 Pointcut：切入点，即一组连接点的集合 Advice：增强，指特定连接点上执行的动作 Introduction：引介，指为一个已有的Java对象动态的增加新的接口 Weaving：织入，指将切面整合到程序的执行流程中 Interceptor：拦截器，是一种实现增强的方式 Target Object：目标对象，即真正执行业务的核心逻辑对象 AOP Proxy：AOP 代理，是客户端持有的增强后的对象引用 要实现 AOP，我们先要引入 Spring 对 AOP 的支持：\norg.springframework:spring-aspects:6.0.0\n然后定义一个 Aspect：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Aspect @Component public class LoggingAspect { // 在执行 UserService 的每个方法前执行 @Before(\u0026#34;execution(public * com.gaj.demo01aop.service.UserService.*(..))\u0026#34;) public void doAccessCheck() { System.err.println(\u0026#34;[Before] do access check...\u0026#34;); } // 在执行 MailService 的每个方法前后执行 @Around(\u0026#34;execution(public * com.gaj.demo01aop.service.MailService.*(..))\u0026#34;) public Object doLogging(ProceedingJoinPoint pjp) throws Throwable { System.err.println(\u0026#34;[Around] start \u0026#34; + pjp.getSignature()); Object retval = pjp.proceed(); System.err.println(\u0026#34;[Around] done \u0026#34; + pjp.getSignature()); return retval; } } @Before 注解后面的字符串是告诉 AspectJ应该在何处执行该方法，这里写的意思是：执行 UserService 的每个 public 方法前执行 doAccessCheck() 代码。\n@Around 注解可以决定是否执行目标方法。\n同时还要给 @Configuration 类加上 @EnableAspectJAutoProxy 注解，这样 Spring 的 IoC容器就会自动查找带有 @Aspect 的 Bean，然后根据每个方法的 @Before、@Around 等注解把 AOP 注入到特定的 Bean 中。\n所以使用 AOP 的步骤如下：\n定义执行方法，并在方法上通过 AspectJ 的注解告诉 Spring 应该在何处调用此方法； 标记 @Component 和 @Aspect； 在 @Configuration 类上标注 @EnableAspectJAutoProxy。 拦截器类型：\n@Before\n先拦截代码，再执行目标代码。如果拦截器抛出异常，目标代码就不执行；\n@After\n先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；\n@AfterReturning\n和 @After 不同的是，只有当目标代码正常返回时，才执行拦截器代码；\n@AfterThrowing\n和 @After 不同的是，只有当目标代码正常抛出了异常时，才执行拦截器代码；\n@Around\n能完全控制目标代码是否执行，并且可以在执行前后、抛异常后执行任意拦截代码。\n使用注解装配 AOP 自动装配时，因为不恰当的范围，容易导致意想不到的结果，即很多不需要AOP代理的Bean也被自动代理了，并且，后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配。\n以监控应用程序性能为例，先定义一个性能监控的注解：\n1 2 3 4 5 @Target(METHOD) @Retention(RUNTIME) public @interface MetricTime { String value(); } 在需要被监控的关键方法上标注该注解\n1 2 3 4 5 6 7 8 9 @Component public class UserService { // 监控register()方法性能: @MetricTime(\u0026#34;register\u0026#34;) public User register(String email, String password, String name) { ... } ... } 然后定义切片 MetricAspect\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Aspect @Component public class MetricAspect { @Around(\u0026#34;@annotation(metricTime)\u0026#34;) public Object metric(ProceedingJoinPoint joinPoint, MetricTime metricTime) throws Throwable { String name = metricTime.value(); long start = System.currentTimeMillis(); try { return joinPoint.proceed(); } finally { long t = System.currentTimeMillis() - start; // 写入日志或发送至JMX: System.err.println(\u0026#34;[Metrics] \u0026#34; + name + \u0026#34;: \u0026#34; + t + \u0026#34;ms\u0026#34;); } } } @Around(\u0026quot;@annotation(metricTime)\u0026quot;) 表示符合条件的目标方法时带有 @MetricTime 注解的方法\nAOP 避坑 Spring 通过 CGLIB 动态创建的代理类生成的构造方法中，并未调用 super()，因此从成员变量并未初始化。Java 编译器虽然会默认在构造方法的第一行自动加 super()，但是， CGLIB 构造的代理类，是通过直接生成字节码，没有源码-编译-字节码的这个步骤，因此：\nSpring通过CGLIB创建的代理类，不会初始化代理类自身继承的任何成员变量，包括final类型的成员变量！\n如何解决这个问题，需要在访问字段的代码，改成通过方法访问（用 getter 访问而不用 对象.字段直接访问字段），在代理实例中，因为代理类会覆写 getter 方法，并且将其委托给原始实例：\n1 2 3 4 5 6 7 8 public UserService$$EnhancerBySpringCGLIB extends UserService { UserService target = ... // 原始实例 ... public ZoneId getZoneId() { return target.getZoneId(); // 委托给原始实例 } } 如果有方法是用 public + final 修饰的方法，\n1 2 3 4 5 6 7 @Component public class UserService { ... public final ZoneId getFinalZoneId() { return zoneId; } } 如果在MailService中，调用的不是getZoneId()，而是getFinalZoneId()，又会出现NullPointerException，这是因为，代理类无法覆写final方法（这一点绕不过JVM的ClassLoader检查），该方法返回的是代理类的zoneId字段，即null。\n因此，正确使用AOP，我们需要一个避坑指南：\n访问被注入的Bean时，总是调用方法而非直接访问字段； 编写Bean时，如果可能会被代理，就不要编写public final方法。 这样才能保证有没有AOP，代码都能正常工作。\n","date":"2024-08-26T09:52:54+08:00","permalink":"https://example.com/p/aop/","title":"AOP"},{"content":"Cookie Cookie是另一种在Web应用中保持状态的机制，但与session不同的是，cookie存储在客户端，而不是服务器端。以下是cookie的详细介绍：\n1. Cookie的工作原理 存储位置: cookie存储在客户端的浏览器中，由浏览器管理。 传递机制: 每次客户端发送HTTP请求时，浏览器会自动将相关的cookie信息添加到请求头中发送给服务器。这些cookie可以包含各种数据，如用户ID、偏好设置等。 2. Cookie的创建和使用 设置Cookie:\n服务器通过HTTP响应头中的Set-Cookie指令来设置cookie。\n例如：\n1 2 3 Cookie cookie = new Cookie(\u0026#34;username\u0026#34;, \u0026#34;Alice\u0026#34;); cookie.setMaxAge(60 * 60); // 设置cookie的生命周期为1小时 response.addCookie(cookie); 这段代码在服务器响应时，告诉客户端保存一个名为\u0026quot;username\u0026quot;、值为\u0026quot;Alice\u0026quot;的cookie，并设定这个cookie的有效期为1小时。\n读取Cookie:\n服务器可以通过HttpServletRequest对象读取客户端发送的cookie。\n例如：\n1 2 3 4 5 6 7 8 9 Cookie[] cookies = request.getCookies(); if (cookies != null) { for (Cookie c : cookies) { if (\u0026#34;username\u0026#34;.equals(c.getName())) { String username = c.getValue(); // 使用username进行后续操作 } } } 这段代码获取客户端发送的所有cookie，并从中找到名为\u0026quot;username\u0026quot;的cookie，然后提取其值。\n3. Cookie与Session的区别 存储位置: Session存储在服务器端（内存、数据库、文件等）。 Cookie存储在客户端（浏览器）。 生命周期: Session的生命周期通常与客户端会话相关联，且可以配置为持久化或基于时间过期。 Cookie的生命周期由服务器通过Max-Age或Expires属性指定。如果不设置，cookie会在浏览器关闭后失效。 安全性: Session数据在服务器端保存，客户端无法直接访问或篡改，安全性较高。 Cookie数据保存在客户端，虽然可以设置为HttpOnly（仅供服务器读取）或Secure（仅在HTTPS下传输），但仍然容易受到客户端篡改或窃取的风险。 典型用途: Session通常用于存储用户的会话数据（如登录状态），在多个请求之间保持状态。 Cookie可以用于在客户端存储小型数据，如用户偏好、会话ID等。 4. Session与Cookie的关系 通常，session和cookie是一起使用的。为了在多个请求之间识别用户的session，服务器会创建一个session ID，并通过cookie发送给客户端。 每次客户端发送请求时，浏览器会将session ID的cookie返回给服务器，服务器通过这个session ID找到对应的session，从而维持会话状态。 总结 Cookie: 存储在客户端，由服务器通过Set-Cookie设置。每次请求时，浏览器会自动发送相关cookie。 Session: 存储在服务器端，用于管理与特定用户的会话状态。通常通过session ID来关联客户端和服务端的会话。 Cookie和session各有其用途，通常根据应用需求选择最适合的方式来管理用户状态。\n","date":"2024-08-25T08:52:54+08:00","image":"https://example.com/p/cookie/cookie_hu8143540753659831620.jpg","permalink":"https://example.com/p/cookie/","title":"Cookie"},{"content":"Filter \u0026amp; DispatcherServlet \u0026amp; Interceptor Filter 过滤器，它是 JavaEE 的 Servlet 规范提供的一种组件\n作用\n在 Http 请求到达 Servlet 之前，可以被一个或多个 Filter 预处理，主要是做的一些代码的公共逻辑。\n调用链\n多个 Filter 是具有调用链的存在的，每个请求都会被链上的 Filter 依次处理，需要在 web.xml 中配置它们的顺序。\nFilter 可以有针对性地拦截或者放行 HTTP 请求，如果在 Filter 内部直接发送重定向，且没有调用 chain.doFilter() ，后续的 Filter 就不会在处理这个请求了\nDispatcherServlet 它是 MVC 框架中用来接收所有请求的 Servlet，总是映射到 /\nDispatcherServlet 在接收到一个 Request 之后，会根据 Controller 的注解来决定调用哪个方法（需要先通过反射获取 Controller 的实例、get 或 post 方法、方法的参数类型、方法的参数名称），并获得方法返回的 ModelAndView ，或方法内部已经自行处理完毕，返回的就是 null\nView 使用来给模板引擎指定渲染的模板的，而 Model 是一个 Map\u0026lt;String, Object\u0026gt;，model 会由渲染引擎（如 Pebble 这类引擎）在生成模板的时候通过反射来获取数据\nInterceptor 拦截器，它是 Spring MVC 框架用于拦截 HTTP 请求的逻辑\n作用于请求到 controller 之前、controller 处理请求之后\n作用范围比 Filter 更小，更加精细\n","date":"2024-08-25T08:52:54+08:00","permalink":"https://example.com/p/filter-dispatcherservlet-interceptor/","title":"Filter \u0026 DispatcherServlet \u0026 Interceptor"},{"content":"Session session用于指代服务器将数据存储在当前用户的会话中，这个session是由服务端保存的，具体来说，它是一个HttpSession类，我们在获取的时候是由HttpServletRequest.getSession()这样获取到当前用户的session，通过唯一表示符JSESSIONID在服务端区分。\n客户端只会保存JSESSIONID，服务端通过这个id查找到对应的session。\n服务端通过setAttribute()和getAttribute()来读或写session存储的属性及其值\n但是，HttpServletRequest在响应完请求后就会销毁，说明这个Session不是由HttpServletRequest，而是由tomcat的相关组件来处理的：\norg.apache.catalina.session.StandardSession:\nStandardSession是Tomcat中表示会话的类。每个会话对象都由这个类的一个实例表示，StandardSession对象包含了会话的所有数据，包括会话ID、会话属性（如user、name）、创建时间、最后访问时间等。 org.apache.catalina.session.StandardManager:\nStandardManager是Tomcat的默认会话管理器，它负责创建、查找、删除和持久化StandardSession对象。 当你通过HttpServletRequest.getSession()获取会话时，Tomcat实际上是通过StandardManager查找或创建一个StandardSession对象。 org.apache.catalina.Context:\nContext对象代表一个Web应用的上下文。在每个Context对象中，有一个Manager（即StandardManager）实例来管理该上下文的所有会话。 工作流程概述 创建会话: 当客户端第一次请求并调用HttpServletRequest.getSession()时，如果没有现有的会话，Tomcat会通过StandardManager创建一个新的StandardSession对象并返回。 这个新创建的会话对象会被StandardManager保存，以便在后续请求中使用。 管理会话生命周期: StandardManager会定期检查会话是否过期，并销毁过期的会话。 如果应用程序或服务器设置了持久化配置，StandardManager还可以将会话数据序列化到文件系统中，以便在服务器重启后恢复。 会话存储: 默认情况下，session数据存储在Tomcat服务器的内存中。StandardManager会持有所有活动会话的引用，并在Tomcat运行期间负责管理它们。 会话在Tomcat中的持有者 因此，在Tomcat中，HttpSession对象是由StandardSession类表示的，而这些会话对象由StandardManager持有和管理。即使HttpServletRequest对象被销毁，StandardSession对象依然存在于StandardManager中，直到会话超时或被显式销毁。\n如果Tomcat重启，默认情况下，保存在内存中的session会消失。这意味着如果没有特殊配置，当Tomcat重新启动时，所有活跃的session数据都会丢失，用户会话将被中断，用户需要重新登录或重新建立会话。\n持久化会话数据的方法 为了在Tomcat重启后保留session数据，可以使用以下方法：\n启用session持久化:\nTomcat提供了会话持久化的功能，可以将session数据序列化到磁盘上，并在服务器重启时重新加载。 这通过StandardManager的持久化机制来实现。你可以在\u0026lt;Context\u0026gt;配置中启用session持久化。 示例配置（在conf/context.xml或Web应用的META-INF/context.xml中）：\n1 \u0026lt;Manager pathname=\u0026#34;session.ser\u0026#34;/\u0026gt; 这里的pathname属性指定了会话数据文件的路径。如果不指定路径，Tomcat将默认保存会话数据到work目录下的session.ser文件中。 使用外部持久化存储:\n可以将session数据存储在外部数据库、Redis、Memcached等持久化存储中。通过这种方式，即使Tomcat重启，会话数据也能持久存在。 这需要自定义Manager类或者使用第三方的解决方案，例如使用RedisSessionManager来将session数据保存在Redis中。 总结 默认情况下，Tomcat重启后，session数据会丢失，因为它们存储在内存中。\n启用持久化 或 使用 外部存储 是保留session数据的两种常见方法。如果需要在重启后保持会话，建议配置持久化或者使用外部存储机制。\n","date":"2024-08-25T08:52:54+08:00","permalink":"https://example.com/p/session/","title":"Session"},{"content":"测试文章 测试内容\n测试 toc 自动生成目录1 测试 toc 自动生成多级目录（二级目录） 测试 toc 自动生成多级目录（三级目录） 多级目录最多三层\n测试 toc 自动生成目录2 下面是图片↓↓↓↓↓↓↓↓↓↓↓↓\n上面是图片↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n图片中间不能有空格\n测试图片上传方案 测试代码块\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* 读取配置文件 使用 @PropertySource(\u0026#34;app.properties\u0026#34;) 自动读取配置文件，Spring 容器看到这个注解后，自动读取这个配置文件 */ @Configuration @ComponentScan @PropertySource(\u0026#34;app.properties\u0026#34;) // 表示读取 classpath 的 app.properties @PropertySource(\u0026#34;smtp.properties\u0026#34;) public class AppConfig { @SuppressWarnings(\u0026#34;resource\u0026#34;) public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); UserService userService = context.getBean(UserService.class); userService.login(\u0026#34;bob@example.com\u0026#34;, \u0026#34;password\u0026#34;); Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;ada\u0026#34;, 2); map.put(\u0026#34;awui\u0026#34;, 1); map.put(\u0026#34;dawcf\u0026#34;, 3); map.put(\u0026#34;afafds\u0026#34;, 4); for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { System.out.println(entry.getKey() + entry.getValue()); } } /* 注入的字符串语法 1.\u0026#34;${app.zone}\u0026#34; 表示读取 key 为 app.zone 的 value，如果 key 不存在，启动将报错 2.\u0026#34;${app.zone:Z}\u0026#34; 表示读取 key 为 app.zone 的 value，如果 key 不存在，就用使用默认值 */ @Bean ZoneId createZoneId(@Value(\u0026#34;${app.zone:Z}\u0026#34;) String zoneId) { return ZoneId.of(zoneId); } } ","date":"2023-08-24T09:52:54+08:00","image":"https://example.com/p/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87_hu6886787404485992962.png","permalink":"https://example.com/p/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","title":"测试文章"}]